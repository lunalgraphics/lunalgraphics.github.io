import "./chunk-SA3VOP2B.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  children,
  claim_element,
  claim_space,
  claim_text,
  detach_dev,
  dispatch_dev,
  element,
  init,
  insert_hydration_dev,
  listen_dev,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  src_url_equal,
  text,
  validate_slots
} from "./chunk-3XCKNI7N.js";
import "./chunk-EKIRE5YT.js";
import "./chunk-V6TY7KAL.js";

// node_modules/svelte-imageslider/src/ImageSlider.svelte
var file = "node_modules/svelte-imageslider/src/ImageSlider.svelte";
function add_css(target) {
  append_styles(target, "svelte-a8uwvm", ".imageSlider.svelte-a8uwvm.svelte-a8uwvm{display:inline-block;width:100%;position:relative}.imageSlider.svelte-a8uwvm img.svelte-a8uwvm{display:block;user-select:none;-moz-user-select:none;-webkit-user-select:none;-webkit-user-drag:none}.imageSlider.svelte-a8uwvm .invisibleCover.svelte-a8uwvm{position:absolute;top:0;left:0;width:100%;height:100%}.imageSlider.svelte-a8uwvm .imageLabel.svelte-a8uwvm{position:absolute;bottom:0;padding:8px;background-color:rgba(0, 0, 0, 42%);color:white;font-size:12px;font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VTbGlkZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQThFSSx3Q0FBYSxDQUNULE9BQU8sQ0FBRSxZQUFZLENBQ3JCLEtBQUssQ0FBRSxJQUFJLENBQ1gsUUFBUSxDQUFFLFFBQ2QsQ0FFQSwwQkFBWSxDQUFDLGlCQUFJLENBQ2IsT0FBTyxDQUFFLEtBQUssQ0FDZCxXQUFXLENBQUUsSUFBSSxDQUNqQixnQkFBZ0IsQ0FBRSxJQUFJLENBQ3RCLG1CQUFtQixDQUFFLElBQUksQ0FDekIsaUJBQWlCLENBQUUsSUFDdkIsQ0FFQSwwQkFBWSxDQUFDLDZCQUFnQixDQUN6QixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLElBQUksQ0FBRSxDQUFDLENBQ1AsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFDWixDQUVBLDBCQUFZLENBQUMseUJBQVksQ0FDckIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLENBQUMsQ0FDVCxPQUFPLENBQUUsR0FBRyxDQUNaLGdCQUFnQixDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3BDLEtBQUssQ0FBRSxLQUFLLENBQ1osU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsVUFDdEQiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkltYWdlU2xpZGVyLnN2ZWx0ZSJdfQ== */");
}
function create_if_block_1(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*caption1*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*caption1*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "imageLabel svelte-a8uwvm");
      set_style(span, "left", "0");
      add_location(span, file, 56, 18, 1620);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*caption1*/
      4) set_data_dev(
        t,
        /*caption1*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(57:4) {#if caption1}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*caption2*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*caption2*/
        ctx[3]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "imageLabel svelte-a8uwvm");
      set_style(span, "right", "0");
      add_location(span, file, 57, 18, 1703);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*caption2*/
      8) set_data_dev(
        t,
        /*caption2*/
        ctx2[3]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(58:4) {#if caption2}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div3;
  let div0;
  let img0;
  let img0_src_value;
  let img0_draggable_value;
  let t0;
  let div1;
  let img1;
  let img1_src_value;
  let img1_draggable_value;
  let t1;
  let t2;
  let t3;
  let div2;
  let globalMousemove_action;
  let globalMouseup_action;
  let mounted;
  let dispose;
  let if_block0 = (
    /*caption1*/
    ctx[2] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*caption2*/
    ctx[3] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      img0 = element("img");
      t0 = space();
      div1 = element("div");
      img1 = element("img");
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      div2 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { style: true });
      var div0_nodes = children(div0);
      img0 = claim_element(div0_nodes, "IMG", {
        src: true,
        alt: true,
        style: true,
        draggable: true,
        class: true
      });
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      img1 = claim_element(div1_nodes, "IMG", {
        src: true,
        alt: true,
        style: true,
        draggable: true,
        class: true
      });
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      if (if_block0) if_block0.l(div3_nodes);
      t2 = claim_space(div3_nodes);
      if (if_block1) if_block1.l(div3_nodes);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true, style: true });
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img0.src, img0_src_value = /*src1*/
      ctx[0])) attr_dev(img0, "src", img0_src_value);
      attr_dev(img0, "alt", "before");
      set_style(img0, "width", "100%");
      attr_dev(img0, "draggable", img0_draggable_value = false);
      attr_dev(img0, "class", "svelte-a8uwvm");
      add_location(img0, file, 51, 8, 1241);
      attr_dev(div0, "style", "");
      add_location(div0, file, 50, 4, 1218);
      if (!src_url_equal(img1.src, img1_src_value = /*src2*/
      ctx[1])) attr_dev(img1, "src", img1_src_value);
      attr_dev(img1, "alt", "after");
      set_style(img1, "height", "100%");
      set_style(img1, "float", "right");
      attr_dev(img1, "draggable", img1_draggable_value = false);
      attr_dev(img1, "class", "svelte-a8uwvm");
      add_location(img1, file, 54, 8, 1506);
      set_style(div1, "position", "absolute");
      set_style(div1, "top", "0");
      set_style(div1, "right", "0");
      set_style(div1, "height", "100%");
      set_style(div1, "overflow-x", "hidden");
      set_style(div1, "width", 100 - /*sliderPercent*/
      ctx[4] + "%");
      set_style(div1, "border-left", "4px solid white");
      set_style(div1, "transition", "width 0.1s");
      add_location(div1, file, 53, 4, 1327);
      attr_dev(div2, "class", "invisibleCover svelte-a8uwvm");
      set_style(
        div2,
        "cursor",
        /*dragging*/
        ctx[5] ? "ew-resize" : "pointer"
      );
      add_location(div2, file, 58, 4, 1773);
      attr_dev(div3, "class", "imageSlider svelte-a8uwvm");
      add_location(div3, file, 49, 0, 1188);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, img0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, img1);
      append_hydration_dev(div3, t1);
      if (if_block0) if_block0.m(div3, null);
      append_hydration_dev(div3, t2);
      if (if_block1) if_block1.m(div3, null);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      if (!mounted) {
        dispose = [
          listen_dev(
            div2,
            "mousedown",
            /*mousedown_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          action_destroyer(globalMousemove_action = globalMousemove.call(null, div2)),
          action_destroyer(globalMouseup_action = globalMouseup.call(null, div2)),
          listen_dev(
            div2,
            "gmousemove",
            /*gmousemove_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "gmouseup",
            /*gmouseup_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*src1*/
      1 && !src_url_equal(img0.src, img0_src_value = /*src1*/
      ctx2[0])) {
        attr_dev(img0, "src", img0_src_value);
      }
      if (dirty & /*src2*/
      2 && !src_url_equal(img1.src, img1_src_value = /*src2*/
      ctx2[1])) {
        attr_dev(img1, "src", img1_src_value);
      }
      if (dirty & /*sliderPercent*/
      16) {
        set_style(div1, "width", 100 - /*sliderPercent*/
        ctx2[4] + "%");
      }
      if (
        /*caption1*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div3, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*caption2*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(div3, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*dragging*/
      32) {
        set_style(
          div2,
          "cursor",
          /*dragging*/
          ctx2[5] ? "ew-resize" : "pointer"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function globalMousemove(node) {
  const handleEvt = (e) => {
    node.dispatchEvent(new MouseEvent("gmousemove", e));
  };
  document.addEventListener("mousemove", handleEvt, true);
  return {
    destroy() {
      document.removeEventListener("mousemove", handleEvt, true);
    }
  };
}
function globalMouseup(node) {
  const handleEvt = (e) => {
    node.dispatchEvent(new MouseEvent("gmouseup", e));
  };
  document.addEventListener("mouseup", handleEvt, true);
  return {
    destroy() {
      document.removeEventListener("mouseup", handleEvt, true);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageSlider", slots, []);
  let sliderPercent = 50;
  onMount(() => {
  });
  let { src1 } = $$props;
  let { src2 } = $$props;
  let { caption1 = "" } = $$props;
  let { caption2 = "" } = $$props;
  let dragging = false;
  function handleDrag(e) {
    $$invalidate(4, sliderPercent = (e.pageX - e.target.getBoundingClientRect().x) / e.target.getBoundingClientRect().width * 100);
    $$invalidate(4, sliderPercent = Math.min(Math.max(sliderPercent, 0), 100));
  }
  $$self.$$.on_mount.push(function() {
    if (src1 === void 0 && !("src1" in $$props || $$self.$$.bound[$$self.$$.props["src1"]])) {
      console.warn("<ImageSlider> was created without expected prop 'src1'");
    }
    if (src2 === void 0 && !("src2" in $$props || $$self.$$.bound[$$self.$$.props["src2"]])) {
      console.warn("<ImageSlider> was created without expected prop 'src2'");
    }
  });
  const writable_props = ["src1", "src2", "caption1", "caption2"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageSlider> was created with unknown prop '${key}'`);
  });
  const mousedown_handler = (e) => {
    e.preventDefault();
    $$invalidate(5, dragging = true);
    handleDrag(e);
  };
  const gmousemove_handler = (e) => {
    e.preventDefault();
    if (dragging) handleDrag(e);
  };
  const gmouseup_handler = () => {
    $$invalidate(5, dragging = false);
  };
  $$self.$$set = ($$props2) => {
    if ("src1" in $$props2) $$invalidate(0, src1 = $$props2.src1);
    if ("src2" in $$props2) $$invalidate(1, src2 = $$props2.src2);
    if ("caption1" in $$props2) $$invalidate(2, caption1 = $$props2.caption1);
    if ("caption2" in $$props2) $$invalidate(3, caption2 = $$props2.caption2);
  };
  $$self.$capture_state = () => ({
    onMount,
    sliderPercent,
    src1,
    src2,
    caption1,
    caption2,
    dragging,
    handleDrag,
    globalMousemove,
    globalMouseup
  });
  $$self.$inject_state = ($$props2) => {
    if ("sliderPercent" in $$props2) $$invalidate(4, sliderPercent = $$props2.sliderPercent);
    if ("src1" in $$props2) $$invalidate(0, src1 = $$props2.src1);
    if ("src2" in $$props2) $$invalidate(1, src2 = $$props2.src2);
    if ("caption1" in $$props2) $$invalidate(2, caption1 = $$props2.caption1);
    if ("caption2" in $$props2) $$invalidate(3, caption2 = $$props2.caption2);
    if ("dragging" in $$props2) $$invalidate(5, dragging = $$props2.dragging);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    src1,
    src2,
    caption1,
    caption2,
    sliderPercent,
    dragging,
    handleDrag,
    mousedown_handler,
    gmousemove_handler,
    gmouseup_handler
  ];
}
var ImageSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        src1: 0,
        src2: 1,
        caption1: 2,
        caption2: 3
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageSlider",
      options,
      id: create_fragment.name
    });
  }
  get src1() {
    throw new Error("<ImageSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src1(value) {
    throw new Error("<ImageSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src2() {
    throw new Error("<ImageSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src2(value) {
    throw new Error("<ImageSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption1() {
    throw new Error("<ImageSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption1(value) {
    throw new Error("<ImageSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption2() {
    throw new Error("<ImageSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption2(value) {
    throw new Error("<ImageSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageSlider_default = ImageSlider;

// node_modules/svelte-imageslider/src/index.js
var src_default = ImageSlider_default;
export {
  src_default as default
};
//# sourceMappingURL=svelte-imageslider.js.map
